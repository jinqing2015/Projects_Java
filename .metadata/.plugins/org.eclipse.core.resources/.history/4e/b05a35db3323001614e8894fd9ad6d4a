package cn.bh.LeetCode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class LeetCode {
	//21
	public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null && l2 == null)
        	return null;
		if(l1 == null || l2 == null)
        	return l1 == null ? l2 : l1;
		
		ListNode head = null;
		ListNode p1, p2;
		if(l1.val < l2.val){
			head = l1;
			l1 = l1.next;
		}else{
			head = l2;
			l2 = l2.next;
		}
		p1 = l1;
		p2 = l2;
		ListNode q = head;
		while(p1 != null && p2 != null){
			if(p1.val < p2.val){
				q.next = p1;
				p1 = p1.next;
			}else{
				q.next = p2;
				p2 = p2.next;
			}
			q = q.next;
		}
		q.next = (p1 == null? p2: p1);
		return head;
        
    }
	//24
	public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null)
        	return head;
        ListNode p = head;
        ListNode q = head.next;
        head = q;
        //开头两个
        p.next = q.next;
    	q.next = p;
    	ListNode p_front = p;
        while(q != null && p != null){
        	p.next = q.next;
        	q.next = p;
        	p_front.next = q;
        	p = p.next;
        	if(p == null)
        		break;
        	q = p.next;
        }        
        return head;
        /*
         if(head==null||head.next==null)
                return head;
            ListNode p1 = head;
            ListNode p2 = p1.next;
            ListNode p3 = p2.next;
            p2.next = p1;
            p1.next = swapPairs(p3);
            return p2;
         */
        
    }
	//88
	public void merge(int[] nums1, int m, int[] nums2, int n) {
       int index = m + n - 1;
       int p1 = m - 1;
       int p2 = n - 1;
       while(index >= 0){
    	  if(p1 < 0) nums1[index--] = nums2[p2--];
    	  else if(p2 < 0) return;
    	  else
    		  nums1[index--] = (nums1[p1] > nums2[p2] ? nums1[p1--]: nums2[p2--]);
       }
    }
	//102
	public List<List<Integer>> levelOrder(TreeNode root) {
		List<List<Integer>> ret = new ArrayList<>();
		if(root == null)
			return ret;
		
		Deque<TreeNode> nodeQueue = new LinkedList<>();
		nodeQueue.offer(root);
		while(!nodeQueue.isEmpty()){
			List<Integer> tempList = new ArrayList<>();
			int nodenum = nodeQueue.size();
			while(nodenum-- > 0){
				TreeNode temp = nodeQueue.remove();
				tempList.add(temp.val);
				if(temp.left != null)
					nodeQueue.offer(temp.left);
				if(temp.right != null)
					nodeQueue.offer(temp.right);
			}
			ret.add(tempList);
		}
		return ret;
		
    }
	//107
	public List<List<Integer>> levelOrderBottom(TreeNode root) {
		List<List<Integer>> ret = new ArrayList<>();
		if(root == null)
			return ret;
		
		Deque<TreeNode> nodeQueue = new LinkedList<>();
		nodeQueue.offer(root);
		while(!nodeQueue.isEmpty()){
			List<Integer> tempList = new ArrayList<>();
			int nodenum = nodeQueue.size();
			while(nodenum-- > 0){
				TreeNode temp = nodeQueue.remove();
				tempList.add(temp.val);
				if(temp.left != null)
					nodeQueue.offer(temp.left);
				if(temp.right != null)
					nodeQueue.offer(temp.right);
			}
			ret.add(tempList);
		}
		return ret;
    }
	//110
	public boolean isBalanced(TreeNode root) {
		if(root == null)
             return true; 
		if(Math.abs(highTree(root.left) - highTree(root.right)) > 1)
	    	 return false;
	     return isBalanced(root.right) && isBalanced(root.left);
	}
	public int highTree(TreeNode root){
		if(root == null)
			return 0;
		return 1 + Math.max(highTree(root.left), highTree(root.right));
	}
	//198
	public int rob(int[] nums) {
		if(nums==null||nums.length==0){
	        return 0;
	    }
	    int n0 = 0;  // 记录没有选择当前houses时的获取的最大金额
	    int n1 = 0;  // 记录选择当前houses时的获取的最大金额
	    for(int i=0; i<nums.length; i++){
	        int tmp = n0;
	        n0 = Math.max(n0,n1);  //没有选择当前houses，那么它等于上次选择了或没选择的最大值  
	        n1 = tmp+nums[i];  //选择了当前houses，值只能等于上次没选择的+当前houses的money
	    }
	    return Math.max(n0, n1);
		//return maxRob(nums, 0);
    }
	public int maxRob(int[] nums, int n){
		if(n > nums.length - 1)
			return 0;
		return nums[n] + Math.max(maxRob(nums, n + 2),maxRob(nums, n + 3));
	}
	public int[] intersection1(int[] nums1, int[] nums2) {
		Set<Integer> nums = new HashSet<>();
		Set<Integer> ret = new HashSet<>();
		
		for(int num : nums1)	nums.add(num);
		for(int num : nums2)
			if(!nums.contains(num))
				ret.add(num);
		int[] retNums = new int[ret.size()];
		int i = 0;
		for(int num : ret) retNums[i++] = num;
		return retNums;
    }
	public int[] intersection2(int[] nums1, int[] nums2) {
        Set<Integer> ret = new HashSet<>();
		Arrays.sort(nums1);
		Arrays.sort(nums2);
		int i,j;
		i = j = 0;
		while(i < nums1.length  && j < nums2.length ){			
			if(nums1[i] == nums2[j]){
				ret.add(nums1[i]);
				i++;
				j++;
			}else if(nums1[i] > nums2[j])
				j++;
			else
				i++;
		}
		int[] retNums = new int[ret.size()];
		for(int num : ret) retNums[i++] = num;	
		return retNums;	
    }
	//350
	public int[] intersection(int[] nums1, int[] nums2) {
		List<Integer> ret = new LinkedList<>();
		Arrays.sort(nums1);
		Arrays.sort(nums2);
		int i,j;
		i = j = 0;
		while(i < nums1.length  && j < nums2.length ){			
			if(nums1[i] == nums2[j]){
				ret.add(nums1[i]);
				i++;
				j++;
			}else if(nums1[i] > nums2[j])
				j++;
			else
				i++;
		}
		i = 0;
		int[] retNums = new int[ret.size()];
		for(int num : ret) retNums[i++] = num;	
		return retNums;
	}
	public static int climbStairs2(int n) {
        return fib(1, 2, n);
    }

    public static int fib(int a, int b, int n) {
        if (n <= 1) 
        	return a;
        else 
        	return fib(b, a+b, n-1);
    }
	public static int climbStairs(int n) {
		if(n <= 0)
			return 0;
		if(n == 1)
			return 1;
		if(n == 2)
			return 2;
		return climbStairs(n - 1) + climbStairs(n - 2);
    }
	public ListNode deleteDuplicates(ListNode head) {
		if(head == null || head.next == null)
			return head;
		ListNode p = head;
		while(p != null){
			ListNode q = p.next;
			while(q != null && q.val == p.val)
				q = q.next;
			p.next = q;
			p = p.next;
		}
		return head;
    }
	//141
	public boolean hasCycle(ListNode head) {
        if(head == null)
        	return false;
        ListNode p = head;
        ListNode q = p;
        while(q != null){
        	q = q.next;
        	if(q == null)
        		return false;
        	q = q.next;
        	if(q == null)
        		return false;
        	p = p.next;
        	if(q == p)
        		return true;
        }
        return false;
    }
	//142
	public ListNode detectCycle(ListNode head) {
		if(head == null)
        	return null;
        ListNode slow = head;
        ListNode fast = slow;
        while(fast != null && fast.next != null){
        	fast = fast.next.next;
        	slow = slow.next;
        	if(fast == slow)
        		break;
        }
        if(fast == null || fast.next == null)
        	return null;
        slow = head;
        while(slow != fast){
        	slow = slow.next;
        	fast = fast.next;
        }
        return slow;
		
    }
	//121
	public int maxProfit(int[] prices) {
		int min = 0;
        int mp = 0;

        for (int i = 1; i < prices.length; i++) {
            if (prices[min] > prices[i]) min = i;
            else mp = Math.max(mp, prices[i] - prices[min]);
        }

        return mp;
    }
	//235
	public TreeNode lowestCommonAncestor_Average(TreeNode root, TreeNode p, TreeNode q) {
        
		if(root == null || p == null || q == null)
			return null;
		else if(p.val < root.val && q.val < root.val)
			return lowestCommonAncestor(root.left, p , q);
		else if(p.val > root.val && q.val > root.val)
			return lowestCommonAncestor(root.right, p, q);
		else
			return root;
	
    }
	//236
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		
		if (root == null || root == p || root == q) {
	        return root;
	    }
	    TreeNode l = lowestCommonAncestor(root.left, p, q);
	    TreeNode r = lowestCommonAncestor(root.right, p, q);
	    return l != null && r != null?root : l == null?r: l;
    }
	
	public static void main(String args[]){
		System.out.println(climbStairs(1));
		System.out.println(climbStairs(2));
		System.out.println(climbStairs(3));
		System.out.println(climbStairs(4));
		System.out.println(climbStairs(5));
		System.out.println(climbStairs(6));
		System.out.println(climbStairs(7));
		System.out.println(climbStairs(8));
		System.out.println(climbStairs(9));
	}
}
